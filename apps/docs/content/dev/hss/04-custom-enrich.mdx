---
title: Custom enrichment scripts
---

# Custom Enrichment Scripts

Custom enrichment scripts allow you to modify and enhance IIIF resources after data extraction. These scripts are the final processing step before resources are written to disk, making them perfect for adding computed properties, rewriting URLs, injecting metadata, and transforming the IIIF structure itself.

## Overview

Enrichment scripts differ from extraction scripts in their purpose:

- **Extraction scripts** gather and analyze data from resources
- **Enrichment scripts** modify the IIIF resources directly using the extracted data

Enrichment scripts have full access to:

- The IIIF Builder API for modifying resources
- All extracted metadata and indices
- File system access for additional processing
- The ability to mark resources as "changed" to trigger re-serialization

## Getting Started

### Basic Enrichment Script

Here's a simple enrichment script that adds homepage properties to manifests:

```ts filename="scripts/add-homepage.js#L1-25"
import { enrich } from "iiif-hss";

enrich(
  {
    id: "add-homepage",
    name: "Add Homepage Links",
    types: ["Manifest"],
    invalidate: async (resource, api) => {
      // Check if homepage already exists
      const hasHomepage = api.resource.homepage?.length > 0;
      return !hasHomepage;
    },
  },
  async (resource, api) => {
    const serverUrl = api.config.server?.url;
    const homepageUrl = `${serverUrl}/${resource.slug}`;

    // Use the builder API to modify the manifest
    api.builder.editManifest(resource.id, (manifest) => {
      manifest.setHomepage({
        id: homepageUrl,
        type: "Text",
        label: { en: ["View Online"] },
        format: "text/html",
      });
    });

    return {
      didChange: true,
      meta: { homepageAdded: homepageUrl },
    };
  },
);
```

## API Reference

### The `enrich()` Function

The `enrich()` function registers a custom enrichment step:

```ts filename="api-example.js#L1-10"
enrich(
  {
    // Configuration object
    id: "unique-step-id",
    name: "Human readable name",
    types: ["Manifest", "Collection", "Canvas"],
    // ... other options
  },
  async (resource, api) => {
    // Handler function that modifies resources
    return { didChange: boolean /* other data */ };
  },
);
```

### Configuration Object

#### Required Properties

- `id` (string): Unique identifier for your enrichment step
- `name` (string): Human-readable name for logging
- `types` (string[]): Resource types to process (`"Manifest"`, `"Collection"`, `"Canvas"`)

#### Optional Properties

```ts filename="config-options.js#L1-15"
{
  id: "my-enricher",
  name: "My Custom Enricher",
  types: ["Manifest"],

  // Invalidation function - determines when to re-run
  invalidate: async (resource, api) => {
    const cache = await api.caches.value;
    return !cache.enriched; // Re-run if not cached
  },

  // Collection phase - runs after all individual resources
  collect: async (temp, api, config) => {
    // Process aggregated data from all resources
  }
}
```

### Handler Function API

The handler function receives two parameters:

#### 1. `resource` - Resource Information

```ts filename="resource-api.js#L1-8"
async (resource, api) => {
  // Resource metadata
  console.log(resource.id); // IIIF resource ID
  console.log(resource.type); // "Manifest", "Collection", "Canvas"
  console.log(resource.slug); // URL slug
  console.log(resource.storeId); // Source store identifier
  console.log(resource.source); // Source information (disk/remote)
};
```

#### 2. `api` - Enrichment API

```ts filename="api-reference.js#L1-30"
async (resource, api) => {
  // The loaded IIIF resource (read-only reference)
  const manifest = api.resource;

  // IIIF Builder for modifications
  api.builder.editManifest(resource.id, (manifest) => {
    manifest.setLabel({ en: ["New Label"] });
    manifest.setSummary({ en: ["New Summary"] });
    // ... other modifications
  });

  // Extracted data from previous steps
  const metadata = await api.meta.value;
  const indices = await api.indices.value;
  const caches = await api.caches.value;
  const searchRecord = await api.searchRecord.value;

  // File system access
  const filesExist = await api.resourceFiles.exists("thumbnail.jpg");
  await api.resourceFiles.saveText("output.txt", "content");

  // Global configuration and context
  const buildConfig = api.config;
  console.log(api.files); // Directory for this resource's files

  // HTTP request cache for external APIs
  const data = await api.requestCache.fetch("https://api.example.com/data");

  // File handler for global file operations
  await api.fileHandler.saveJson("global-data.json", { data: "example" });
};
```

### Return Values

Enrichment handlers should return an object indicating what changed:

```ts filename="return-values.js#L1-25"
return {
  // REQUIRED: Indicates if the IIIF resource was modified
  didChange: true,

  // Additional metadata to store
  meta: {
    enrichmentApplied: new Date().toISOString(),
    modificationsCount: 3,
  },

  // Search index updates
  indices: {
    newCategories: ["enhanced", "processed"],
  },

  // Cache data for invalidation
  caches: {
    enricherVersion: "2.1.0",
    lastModified: Date.now(),
  },

  // Temporary data for collect phase
  temp: {
    aggregateThis: "data for collection",
  },

  // Search record updates
  search: {
    record: {
      enrichmentScore: 0.95,
    },
  },
};
```

## IIIF Builder API

The builder API provides powerful methods for modifying IIIF resources:

### Manifest Editing

```ts filename="manifest-editing.js#L1-35"
api.builder.editManifest(resource.id, (manifest) => {
  // Basic properties
  manifest.setLabel({ en: ["Updated Title"] });
  manifest.setSummary({ en: ["Updated Description"] });

  // Metadata manipulation
  manifest.addMetadata({
    label: { en: ["Processing Date"] },
    value: { en: [new Date().toISOString()] },
  });

  // Rights and licensing
  manifest.setRights("https://creativecommons.org/licenses/by/4.0/");
  manifest.setRequiredStatement({
    label: { en: ["Attribution"] },
    value: { en: ["Â© 2024 Institution Name"] },
  });

  // Navigation and structure
  manifest.addBehavior("paged");
  manifest.setViewingDirection("left-to-right");

  // Homepage and external links
  manifest.setHomepage({
    id: "https://example.com/item/123",
    type: "Text",
    label: { en: ["View Item"] },
  });

  // Rendering resources
  manifest.addRendering({
    id: "https://example.com/item/123.pdf",
    type: "Text",
    label: { en: ["Download PDF"] },
    format: "application/pdf",
  });

  // Service links
  manifest.addService({
    id: "https://example.com/search/123",
    type: "SearchService1",
  });
});
```

### Vault Actions

For more complex modifications, use vault actions directly:

```ts filename="vault-actions.js#L1-30"
import {
  addReference,
  removeReference,
  changeReferenceIdentifier,
  importEntities,
} from "@iiif/helpers/vault/actions";

// Import new entities
api.builder.vault.dispatch(
  importEntities({
    entities: {
      ContentResource: {
        "new-resource-id": {
          id: "new-resource-id",
          type: "Image",
          format: "image/jpeg",
        },
      },
    },
  }),
);

// Add references
api.builder.vault.dispatch(
  addReference({
    id: resource.id,
    type: "Manifest",
    key: "thumbnail",
    reference: { id: "new-resource-id", type: "ContentResource" },
  }),
);

// Change identifiers
api.builder.vault.dispatch(
  changeReferenceIdentifier({
    id: resource.id,
    type: "Manifest",
    key: "thumbnail",
    index: 0,
    newIdentifier: "https://example.com/new-thumb.jpg",
    reference: existingReference,
  }),
);
```

## Real-World Examples

### Example 1: Label Enhancement from Metadata

Based on the Delft implementation:

```ts filename="scripts/label-enhancement.js#L1-50"
import { enrich } from "iiif-hss";
import { getValue } from "@iiif/helpers";

enrich(
  {
    id: "label-enhancement",
    name: "Enhanced Label Generation",
    types: ["Manifest"],
    invalidate: async (resource, api) => {
      // Re-run if manifest has no label or empty label
      const label = api.resource.label;
      return (
        !label ||
        Object.values(label).every((values) =>
          values.every((value) => !value || value.trim() === ""),
        )
      );
    },
  },
  async (resource, api) => {
    let didChange = false;
    let newLabel = null;

    api.builder.editManifest(resource.id, (manifest) => {
      const currentLabel = manifest.entity.label || {};
      const hasValidLabel =
        Object.keys(currentLabel).length > 0 &&
        Object.values(currentLabel).some((values) =>
          values.some((value) => value && value.trim() !== ""),
        );

      if (!hasValidLabel) {
        // Look for title in metadata
        const metadata = manifest.entity.metadata || [];

        for (const metadataItem of metadata) {
          const labelText = getValue(metadataItem.label);

          // Check for title fields in multiple languages
          if (labelText.match(/^(title|titel|titre)$/i)) {
            newLabel = metadataItem.value;
            manifest.setLabel(newLabel);
            didChange = true;
            break;
          }
        }

        // Fallback: use first non-empty metadata value
        if (!didChange && metadata.length > 0) {
          for (const metadataItem of metadata) {
            const value = getValue(metadataItem.value);
            if (value && value.trim()) {
              newLabel = metadataItem.value;
              manifest.setLabel(newLabel);
              didChange = true;
              break;
            }
          }
        }
      }
    });

    return {
      didChange,
      meta: {
        labelSource: newLabel ? "metadata" : "none",
        labelText: newLabel ? getValue(newLabel) : null,
      },
    };
  },
);
```

### Example 2: File Path Rewriting

Rewrite local file paths to web-accessible URLs:

```ts filename="scripts/file-rewriting.js#L1-80"
import { enrich } from "iiif-hss";
import { toRef } from "@iiif/parser";
import {
  changeReferenceIdentifier,
  addReference,
  importEntities,
} from "@iiif/helpers/vault/actions";

enrich(
  {
    id: "file-rewriting",
    name: "File Path Rewriter",
    types: ["Manifest"],
    invalidate: async (resource, api) => {
      const meta = await api.meta.value;
      return meta.files && meta.files.length > 0;
    },
  },
  async (resource, api) => {
    const meta = await api.meta.value;

    if (!meta.files || meta.files.length === 0) {
      return { didChange: false };
    }

    const baseUrl = api.config.server?.url;
    let didChange = false;

    // Create mapping of local paths to web URLs
    const fileMapping = {};
    for (const file of meta.files) {
      const webUrl = `${baseUrl}/${resource.slug}/files/${file}`;
      fileMapping[file] = webUrl;
      fileMapping[`./${file}`] = webUrl;
      fileMapping[`files/${file}`] = webUrl;
    }

    // Get the manifest and all its items
    const manifest = api.builder.vault.get(resource.id);
    const itemsToCheck = [
      manifest,
      ...api.builder.vault.get(manifest.items || []),
    ];

    // Properties that might contain file references
    const fileProperties = ["thumbnail", "rendering", "seeAlso", "logo"];

    for (const item of itemsToCheck) {
      for (const property of fileProperties) {
        if (item[property]?.length) {
          for (let i = 0; i < item[property].length; i++) {
            const reference = item[property][i];
            const currentId = toRef(reference)?.id;

            if (currentId && fileMapping[currentId]) {
              // Update the reference to point to web URL
              api.builder.vault.dispatch(
                changeReferenceIdentifier({
                  id: item.id,
                  type: item.type,
                  key: property,
                  index: i,
                  newIdentifier: fileMapping[currentId],
                  reference: reference,
                }),
              );
              didChange = true;
            }
          }
        }
      }
    }

    // Add new file resources from filesDetail
    const filesDetail = meta.filesDetail || {};
    for (const [fileName, details] of Object.entries(filesDetail)) {
      if (details.property && !meta.files.includes(fileName)) {
        const fileUrl = `${baseUrl}/${resource.slug}/files/${fileName}`;

        // Import the file resource
        api.builder.vault.dispatch(
          importEntities({
            entities: {
              ContentResource: {
                [fileUrl]: {
                  id: fileUrl,
                  type: details.type || "Dataset",
                  format: details.format,
                  label: details.label,
                  ...details,
                },
              },
            },
          }),
        );

        // Add reference to manifest
        api.builder.vault.dispatch(
          addReference({
            id: manifest.id,
            type: manifest.type,
            key: details.property,
            reference: { id: fileUrl, type: "ContentResource" },
          }),
        );

        didChange = true;
      }
    }

    return {
      didChange,
      meta: {
        filesRewritten: Object.keys(fileMapping).length,
        newResourcesAdded: Object.keys(filesDetail).length,
      },
    };
  },
);
```

### Example 3: Metadata Translation

Translate metadata to multiple languages:

```ts filename="scripts/metadata-translation.js#L1-60"
import { enrich } from "iiif-hss";
import { buildLocaleString } from "@iiif/helpers";

// Mock translation function - replace with real translation service
async function translateText(text, targetLanguage) {
  // This would typically call a translation API
  return `[${targetLanguage.toUpperCase()}] ${text}`;
}

enrich(
  {
    id: "metadata-translation",
    name: "Metadata Translation",
    types: ["Manifest"],
    invalidate: async (resource, api) => {
      const cache = await api.caches.value;
      const targetLangs = ["de", "fr", "es"];

      // Check if translations are cached
      return !targetLangs.every((lang) => cache[`translated_${lang}`]);
    },
  },
  async (resource, api) => {
    const cache = await api.caches.value;
    const targetLanguages = ["de", "fr", "es"];
    const sourceLanguage = "en";

    let didChange = false;
    const translationCache = {};

    api.builder.editManifest(resource.id, async (manifest) => {
      const metadata = manifest.entity.metadata || [];

      if (metadata.length === 0) return;

      const newMetadata = [...metadata];

      for (const [index, metadataItem] of metadata.entries()) {
        const sourceLabel = buildLocaleString(
          metadataItem.label,
          sourceLanguage,
        );
        const sourceValue = buildLocaleString(
          metadataItem.value,
          sourceLanguage,
        );

        if (!sourceLabel || !sourceValue) continue;

        let updatedLabel = { ...metadataItem.label };
        let updatedValue = { ...metadataItem.value };

        for (const targetLang of targetLanguages) {
          const labelCacheKey = `label_${index}_${targetLang}`;
          const valueCacheKey = `value_${index}_${targetLang}`;

          // Use cached translations if available
          let translatedLabel = cache[labelCacheKey];
          let translatedValue = cache[valueCacheKey];

          if (!translatedLabel) {
            translatedLabel = await translateText(sourceLabel, targetLang);
            translationCache[labelCacheKey] = translatedLabel;
          }

          if (!translatedValue) {
            translatedValue = await translateText(sourceValue, targetLang);
            translationCache[valueCacheKey] = translatedValue;
          }

          // Add translations to the metadata item
          updatedLabel[targetLang] = [translatedLabel];
          updatedValue[targetLang] = [translatedValue];
          didChange = true;
        }

        newMetadata[index] = {
          label: updatedLabel,
          value: updatedValue,
        };
      }

      if (didChange) {
        manifest.setMetadata(newMetadata);
      }
    });

    return {
      didChange,
      caches: {
        ...translationCache,
        lastTranslated: Date.now(),
      },
      meta: {
        languagesAdded: targetLanguages,
        metadataItemsTranslated: metadata?.length || 0,
      },
    };
  },
);
```

### Example 4: Canvas Thumbnail Generation

Download and save canvas thumbnails:

```ts filename="scripts/canvas-thumbnails.js#L1-50"
import { enrich } from "iiif-hss";
import { createThumbnailHelper } from "@iiif/helpers";
import fs from "node:fs";
import { join } from "node:path";

enrich(
  {
    id: "canvas-thumbnails",
    name: "Canvas Thumbnail Generator",
    types: ["Canvas"],
    invalidate: async (resource, api) => {
      // Check if thumbnail file already exists
      const thumbPath = join(api.files, "thumb.jpg");
      return !fs.existsSync(thumbPath);
    },
  },
  async (resource, api) => {
    try {
      const helper = createThumbnailHelper(resource.vault);

      // Get the best available thumbnail
      const thumbnail = await helper.getBestThumbnailAtSize(api.resource, {
        width: 400,
        height: 400,
      });

      if (!thumbnail.best?.id) {
        return {
          didChange: false,
          meta: { error: "No thumbnail available" },
        };
      }

      // Only process JPEG images
      if (thumbnail.best.id.match(/\.(jpg|jpeg)$/i)) {
        // Download the thumbnail
        const response = await fetch(thumbnail.best.id);
        if (!response.ok) {
          throw new Error(`Failed to fetch thumbnail: ${response.status}`);
        }

        const arrayBuffer = await response.arrayBuffer();

        // Ensure directory exists
        await fs.promises.mkdir(api.files, { recursive: true });

        // Save thumbnail to disk
        const thumbPath = join(api.files, "thumb.jpg");
        await fs.promises.writeFile(thumbPath, Buffer.from(arrayBuffer));

        return {
          didChange: false, // We're not modifying the IIIF resource
          meta: {
            thumbnailSaved: true,
            thumbnailPath: thumbPath,
            originalUrl: thumbnail.best.id,
            size: arrayBuffer.byteLength,
          },
        };
      }

      return {
        didChange: false,
        meta: { skipped: "Not a JPEG image" },
      };
    } catch (error) {
      console.error(`Thumbnail generation failed for ${resource.slug}:`, error);
      return {
        didChange: false,
        meta: { error: error.message },
      };
    }
  },
);
```

### Example 5: Cross-Resource Enhancement with Collection Phase

Build navigation between related resources:

```ts filename="scripts/navigation-enhancement.js#L1-80"
import { enrich } from "iiif-hss";
import { addReference, importEntities } from "@iiif/helpers/vault/actions";

enrich(
  {
    id: "navigation-enhancement",
    name: "Navigation Enhancement",
    types: ["Manifest"],
    collect: async (temp, api, config) => {
      // Build navigation links between related items
      const relationships = {};
      const allItems = Object.entries(temp);

      // Group items by series/collection
      const groups = {};
      for (const [slug, data] of allItems) {
        const series = data.series || "default";
        if (!groups[series]) groups[series] = [];
        groups[series].push({ slug, ...data });
      }

      // Create navigation for each group
      for (const [series, items] of Object.entries(groups)) {
        if (items.length < 2) continue;

        // Sort items by sequence number or title
        items.sort((a, b) => {
          if (a.sequenceNumber && b.sequenceNumber) {
            return a.sequenceNumber - b.sequenceNumber;
          }
          return (a.title || "").localeCompare(b.title || "");
        });

        // Build navigation relationships
        for (let i = 0; i < items.length; i++) {
          const current = items[i];
          const navigation = {
            series,
            position: i + 1,
            total: items.length,
            previous: i > 0 ? items[i - 1] : null,
            next: i < items.length - 1 ? items[i + 1] : null,
            first: items[0],
            last: items[items.length - 1],
          };

          relationships[current.slug] = navigation;
        }
      }

      // Apply navigation to manifests
      for (const [slug, navigation] of Object.entries(relationships)) {
        const resource = allItems.find(([s]) => s === slug);
        if (!resource) continue;

        const [, data] = resource;
        await enhanceWithNavigation(data.resourceId, navigation, api);
      }
    },
  },
  async (resource, api) => {
    // Extract data for collection phase
    const meta = await api.meta.value;
    const indices = await api.indices.value;

    // Extract series information
    let series = null;
    let sequenceNumber = null;
    let title = null;

    // Look for series in metadata
    if (api.resource.metadata) {
      for (const metadataItem of api.resource.metadata) {
        const label = Object.values(metadataItem.label)[0]?.[0]?.toLowerCase();
        const value = Object.values(metadataItem.value)[0]?.[0];

        if (label?.includes("series") || label?.includes("collection")) {
          series = value;
        }
        if (label?.includes("sequence") || label?.includes("number")) {
          sequenceNumber = parseInt(value) || null;
        }
      }
    }

    // Extract title
    if (api.resource.label) {
      title = Object.values(api.resource.label)[0]?.[0];
    }

    // Use topic-based series if no metadata series found
    if (!series && indices.series) {
      series = indices.series[0];
    }

    return {
      temp: {
        resourceId: resource.id,
        series,
        sequenceNumber,
        title,
        slug: resource.slug,
      },
      meta: {
        navigationDataExtracted: true,
        series,
        sequenceNumber,
      },
    };
  },
);

async function enhanceWithNavigation(resourceId, navigation, api) {
  const baseUrl = api.config.server?.url;

  api.builder.editManifest(resourceId, (manifest) => {
    // Add navigation metadata
    const navMetadata = [
      {
        label: { en: ["Series"] },
        value: { en: [navigation.series] },
      },
      {
        label: { en: ["Position"] },
        value: { en: [`${navigation.position} of ${navigation.total}`] },
      },
    ];

    // Add existing metadata plus navigation
    const existingMetadata = manifest.entity.metadata || [];
    manifest.setMetadata([...existingMetadata, ...navMetadata]);

    // Add seeAlso links for navigation
    const seeAlsoItems = [];

    if (navigation.previous) {
      seeAlsoItems.push({
        id: `${baseUrl}/${navigation.previous.slug}`,
        type: "Manifest",
        label: { en: ["Previous"] },
        profile: "previous",
      });
    }

    if (navigation.next) {
      seeAlsoItems.push({
        id: `${baseUrl}/${navigation.next.slug}`,
        type: "Manifest",
        label: { en: ["Next"] },
        profile: "next",
      });
    }

    // Add series navigation
    seeAlsoItems.push({
      id: `${baseUrl}/series/${encodeURIComponent(navigation.series)}`,
      type: "Collection",
      label: { en: [`View ${navigation.series} Series`] },
      profile: "series",
    });

    if (seeAlsoItems.length > 0) {
      manifest.addSeeAlso(seeAlsoItems);
    }
  });
}
```

## Advanced Features

### Search Index Integration

Add custom search fields from enrichment:

```ts filename="scripts/search-integration.js#L1-25"
enrich(
  {
    id: "search-enhancer",
    name: "Search Enhancement",
    types: ["Manifest"],
    search: {
      manifests: {
        fields: [
          { name: "hasNavigation", type: "bool", optional: true },
          { name: "seriesName", type: "string", facet: true, optional: true },
          { name: "processingDate", type: "int64", optional: true },
        ],
      },
    },
  },
  async (resource, api) => {
    // Your enrichment logic...

    api.builder.editManifest(resource.id, (manifest) => {
      // Modify the manifest...
    });

    return {
      didChange: true,
      search: {
        record: {
          hasNavigation: true,
          seriesName: "Medieval Manuscripts",
          processingDate: Date.now(),
        },
      },
    };
  },
);
```

### Collection-Level Processing

Process collections differently from manifests:

```ts filename="scripts/collection-processing.js#L1-30"
enrich(
  {
    id: "collection-enhancer",
    name: "Collection Enhancer",
    types: ["Collection"],
    invalidate: async (resource, api) => {
      const cache = await api.caches.value;
      return !cache.enhanced;
    },
  },
  async (resource, api) => {
    let didChange = false;

    api.builder.editCollection(resource.id, (collection) => {
      // Add computed summary based on items
      const itemCount = collection.entity.items?.length || 0;

      if (itemCount > 0) {
        collection.setSummary({
          en: [`This collection contains ${itemCount} items.`],
        });
        didChange = true;
      }

      // Add viewing hints for better presentation
      collection.addBehavior("multi-part");
      didChange = true;

      // Set rights information
      collection.setRights(
        "https://creativecommons.org/publicdomain/mark/1.0/",
      );
      didChange = true;
    });

    return {
      didChange,
      caches: { enhanced: true },
      meta: { itemCount: api.resource.items?.length || 0 },
    };
  },
);
```

## Best Practices

### Conditional Modifications

Only modify resources when necessary:

```ts filename="scripts/conditional-modifications.js#L1-30"
enrich(
  {
    id: "conditional-enricher",
    name: "Conditional Enricher",
    types: ["Manifest"],
  },
  async (resource, api) => {
    let didChange = false;
    const modifications = [];

    api.builder.editManifest(resource.id, (manifest) => {
      // Only add homepage if it doesn't exist
      if (!manifest.entity.homepage?.length) {
        const homepage = `${api.config.server?.url}/${resource.slug}`;
        manifest.setHomepage({ id: homepage });
        modifications.push("homepage");
        didChange = true;
      }

      // Only add rights if not present
      if (!manifest.entity.rights) {
        manifest.setRights("https://rightsstatements.org/page/InC/1.0/");
        modifications.push("rights");
        didChange = true;
      }

      // Only add required statement if missing
      if (!manifest.entity.requiredStatement) {
        manifest.setRequiredStatement({
          label: { en: ["Attribution"] },
          value: { en: ["Please cite this resource"] },
        });
        modifications.push("attribution");
        didChange = true;
      }
    });

    return {
      didChange,
      meta: {
        modificationsApplied: modifications,
      },
    };
  },
);
```

### Error Handling

Handle errors gracefully:

```ts filename="scripts/error-handling.js#L1-35"
enrich(
  {
    id: "robust-enricher",
    name: "Robust Enricher",
    types: ["Manifest"],
  },
  async (resource, api) => {
    let didChange = false;
    const errors = [];

    try {
      api.builder.editManifest(resource.id, (manifest) => {
        try {
          // Potentially risky modification
          manifest.setLabel(computeComplexLabel(api.resource));
          didChange = true;
        } catch (error) {
          errors.push(`Label computation failed: ${error.message}`);
        }

        try {
          // Another risky operation
          const thumbnail = generateThumbnailUrl(api.resource);
          if (thumbnail) {
            manifest.addThumbnail({ id: thumbnail });
            didChange = true;
          }
        } catch (error) {
          errors.push(`Thumbnail generation failed: ${error.message}`);
        }
      });
    } catch (error) {
      console.error(`Enrichment failed for ${resource.slug}:`, error);
      return {
        didChange: false,
        meta: {
          error: error.message,
          timestamp: new Date().toISOString(),
        },
      };
    }

    return {
      didChange,
      meta: {
        errors: errors.length > 0 ? errors : null,
        status: errors.length > 0 ? "partial" : "success",
      },
    };
  },
);

function computeComplexLabel(resource) {
  // Complex label computation that might fail
  return { en: ["Computed Label"] };
}

function generateThumbnailUrl(resource) {
  // Thumbnail URL generation that might fail
  return "https://example.com/thumb.jpg";
}
```

## Caching and Performance

### Effective Invalidation

```ts filename="scripts/caching-strategies.js#L1-35"
enrich(
  {
    id: "performance-enricher",
    name: "Performance Optimized Enricher",
    types: ["Manifest"],
    invalidate: async (resource, api) => {
      const cache = await api.caches.value;

      // Version-based invalidation
      if (cache.enricherVersion !== "3.1.0") {
        return true;
      }

      // Check if extracted metadata has changed
      const meta = await api.meta.value;
      const metaHash = JSON.stringify(meta);
      if (cache.metaHash !== metaHash) {
        return true;
      }

      // Time-based invalidation (weekly)
      const week = 7 * 24 * 60 * 60 * 1000;
      if (!cache.lastEnriched || Date.now() - cache.lastEnriched > week) {
        return true;
      }

      return false; // Use cached version
    },
  },
  async (resource, api) => {
    // Expensive enrichment operations here...
    const result = await performExpensiveEnrichment(resource, api);

    const meta = await api.meta.value;

    return {
      didChange: result.modified,
      caches: {
        enricherVersion: "3.1.0",
        lastEnriched: Date.now(),
        metaHash: JSON.stringify(meta),
      },
    };
  },
);

function performExpensiveEnrichment(resource, api) {
  // Simulate expensive operation
  return { modified: true };
}
```

## Configuration in .iiifrc.yml

Add your custom enrichment scripts to the processing pipeline:

```yaml filename="iiifrc.yml#L1-25"
# .iiifrc.yml
server:
  url: http://localhost:7111

run:
  - extract-label-string
  - extract-thumbnail
  - manifest-sqlite
  - label-enhancement # Your custom enrichment
  - file-rewriting # Another custom enrichment
  - navigation-enhancement # Collection-phase enrichment

stores:
  my-content:
    type: iiif-json
    path: ./content
    run:
      - metadata-translation # Store-specific enrichment

config:
  metadata-translation:
    targetLanguages: ["de", "fr", "es"]
    translationService: "google"
    cacheTranslations: true

  navigation-enhancement:
    enableSeries: true
    maxRelated: 5
```

## Common Patterns and Utilities

### Metadata Helpers

```ts filename="metadata-helpers.js#L1-35"
// Utility functions for common enrichment tasks

export function ensureInternationalString(value) {
  if (typeof value === "string") {
    return { none: [value] };
  }
  if (Array.isArray(value)) {
    return { none: value };
  }
  return value;
}

export function mergeInternationalStrings(str1, str2) {
  const merged = { ...str1 };
  for (const [lang, values] of Object.entries(str2)) {
    if (merged[lang]) {
      merged[lang] = [...merged[lang], ...values];
    } else {
      merged[lang] = [...values];
    }
  }
  return merged;
}

export function hasValidLabel(resource) {
  const label = resource.label;
  if (!label) return false;

  return Object.values(label).some((values) =>
    values.some((value) => value && value.trim() !== ""),
  );
}

export function createHomepageReference(baseUrl, slug, label = "View Online") {
  return {
    id: `${baseUrl}/${slug}`,
    type: "Text",
    label: { en: [label] },
    format: "text/html",
  };
}
```

## Debugging

### Debug Logging

```ts filename="debug-logging.js#L1-25"
enrich(
  {
    id: "debug-enricher",
    name: "Debug Enricher",
    types: ["Manifest"],
  },
  async (resource, api) => {
    const debug = process.env.NODE_ENV === "development";

    if (debug) {
      console.log(`[ENRICH] Processing ${resource.slug}`);
      console.log(`[ENRICH] Resource type: ${resource.type}`);
      console.log(`[ENRICH] Store: ${resource.storeId}`);

      const meta = await api.meta.value;
      console.log(`[ENRICH] Available metadata:`, Object.keys(meta));
    }

    const startTime = Date.now();
    let didChange = false;

    api.builder.editManifest(resource.id, (manifest) => {
      // Your enrichment logic here
      if (debug) {
        console.log(`[ENRICH] Current label:`, manifest.entity.label);
      }

      // Make modifications...
      didChange = true;
    });

    if (debug) {
      console.log(
        `[ENRICH] Completed ${resource.slug} in ${Date.now() - startTime}ms`,
      );
      console.log(`[ENRICH] Changes made: ${didChange}`);
    }

    return { didChange };
  },
);
```
